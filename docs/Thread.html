<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>lupro_scheduler.Thread API documentation</title>
<meta name="description" content="线程接口" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>lupro_scheduler.Thread</code></h1>
</header>
<section id="section-intro">
<p>线程接口</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#39;&#39;&#39;线程接口&#39;&#39;&#39;

import threading
from concurrent.futures import ThreadPoolExecutor
from .typing import Union, Callable, Iterable
from .publictool import init_task

# 重写可返回的线程
class Thread(threading.Thread):
    &#39;&#39;&#39;Thread method(可返回)&#39;&#39;&#39;

    def __init__(self, *args, **kwargs):
        super(Thread, self).__init__(*args, **kwargs)
        self.target = kwargs[&#39;target&#39;]
        self.args = kwargs[&#39;args&#39;]
        if kwargs.get(&#39;kwargs&#39;):
            self.kwargs = kwargs[&#39;kwargs&#39;]
        else:
            self.kwargs = {}

    def run(self):
        try:
            if self.target:
                self.results = self.target(*self.args, **self.kwargs)
        finally:
            del self.target, self.args, self.kwargs

    def result(self):
        try:
            return self.results   # 如果子线程不使用join方法，此处可能会报没有self.result的错误
        except Exception:
            return None

# Thread map 特性 函数 必须要一个Iterable对象
class ThreadMap():
    &#39;&#39;&#39;Thread map method&#39;&#39;&#39;

    def __init__(self, target = None, *args : &#34;Iterable[tuple]&#34;, kwargs : &#34;Iterable[dict]&#34; = None, name : Iterable = None,  daemon : Iterable = None):
        if not (args or name or kwargs or daemon or isinstance(target, Iterable)):
            raise TypeError(&#34;ThreadMap() missing 1 required positional argument: &#39;iterable&#39;&#34;)
        d = {&#39;args&#39;: (), &#39;name&#39; : None, &#39;kwargs&#39; : None, &#39;daemon&#39; : None}
        self.task = []
        self.l = 0
        if target and isinstance(target, Iterable):
            self.l = len(target)
            d[&#39;func&#39;] = target
        if args:
            d[&#39;args&#39;] = list(zip(*args))
            self.l = len(d[&#39;args&#39;])
        if name:
            d[&#39;name&#39;] = name
            if not self.l:
                self.l = len(args)
        if kwargs:
            d[&#39;kwargs&#39;] = kwargs
            if not self.l:
                self.l = len(d[&#39;kwargs&#39;])
        if daemon:
            d[&#39;daemon&#39;] = daemon
            if not self.l:
                self.l = len(daemon)
        for i in d:
            if not d[i]:
                d[i] = [d[i]]*self.l
        if isinstance(target, Callable):
            self.task = [Thread(target = target, name = d[&#39;args&#39;][i],args = d[&#39;args&#39;][i], kwargs = d[&#39;kwargs&#39;][i], daemon = d[&#39;daemon&#39;][i]) for i in range(self.l)]
        else:
            self.task = [Thread(target = d[&#39;func&#39;][i], name = d[&#39;args&#39;][i],args = d[&#39;args&#39;][i], kwargs = d[&#39;kwargs&#39;][i], daemon = d[&#39;daemon&#39;][i]) for i in range(self.l)]
        del d
        
    def start(self):
        for i in self.task:
            i.start()
    
    def join(self):
        for i in self.task:
            i.join()

    def result(self):
        self.join()
        return [i.result() for i in self.task]

    def run(self, method = 0, join = True):
        if method == 0:
            self.start()
            if join:
                self.join()
        else:
            raise TypeError(
                f&#34;ThreadMap.run.method({method}) not in Enum RunThreadMap!&#34;)
        return self.result()

# 线程池
class ThreadPool():
    &#39;&#39;&#39;concurrent.futures.ThreadPoolExecutor method&#39;&#39;&#39;

    def __init__(self, func : Union[list, Callable], *args, kwargs = []):
        init_task(self, func = func, args = args, kwargs = kwargs)

    def start(self, max_workers = None, thread_name_prefix=&#39;&#39;, initializer=None, initargs=(), timeout=None, chunksize=1):
        with ThreadPoolExecutor(max_workers, thread_name_prefix , initializer, initargs) as pool:
            if isinstance(self.func, Callable):
                self.task = pool.map(self.func, *self.args, timeout = timeout, chunksize = chunksize)
            else:
                self.task = [pool.submit(self.func[i], *self.d[&#39;args&#39;][i]) for i in range(self.l)]

    def result(self):
        if isinstance(self.task, list):
            return [i.result() for i in self.task]
        return list(self.task)

    def run(self, method = 0):
        if method == 0:
            self.start()
        else:
            raise TypeError(
                f&#34;ThreadPool.run.method({method}) not in Enum ThreadPool!&#34;)
        return self.result()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="lupro_scheduler.Thread.Thread"><code class="flex name class">
<span>class <span class="ident">Thread</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Thread method(可返回)</p>
<p>This constructor should always be called with keyword arguments. Arguments are:</p>
<p><em>group</em> should be None; reserved for future extension when a ThreadGroup
class is implemented.</p>
<p><em>target</em> is the callable object to be invoked by the run()
method. Defaults to None, meaning nothing is called.</p>
<p><em>name</em> is the thread name. By default, a unique name is constructed of
the form "Thread-N" where N is a small decimal number.</p>
<p><em>args</em> is the argument tuple for the target invocation. Defaults to ().</p>
<p><em>kwargs</em> is a dictionary of keyword arguments for the target
invocation. Defaults to {}.</p>
<p>If a subclass overrides the constructor, it must make sure to invoke
the base class constructor (Thread.<strong>init</strong>()) before doing anything
else to the thread.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Thread(threading.Thread):
    &#39;&#39;&#39;Thread method(可返回)&#39;&#39;&#39;

    def __init__(self, *args, **kwargs):
        super(Thread, self).__init__(*args, **kwargs)
        self.target = kwargs[&#39;target&#39;]
        self.args = kwargs[&#39;args&#39;]
        if kwargs.get(&#39;kwargs&#39;):
            self.kwargs = kwargs[&#39;kwargs&#39;]
        else:
            self.kwargs = {}

    def run(self):
        try:
            if self.target:
                self.results = self.target(*self.args, **self.kwargs)
        finally:
            del self.target, self.args, self.kwargs

    def result(self):
        try:
            return self.results   # 如果子线程不使用join方法，此处可能会报没有self.result的错误
        except Exception:
            return None</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>threading.Thread</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="lupro_scheduler.Thread.Thread.result"><code class="name flex">
<span>def <span class="ident">result</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def result(self):
    try:
        return self.results   # 如果子线程不使用join方法，此处可能会报没有self.result的错误
    except Exception:
        return None</code></pre>
</details>
</dd>
<dt id="lupro_scheduler.Thread.Thread.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Method representing the thread's activity.</p>
<p>You may override this method in a subclass. The standard run() method
invokes the callable object passed to the object's constructor as the
target argument, if any, with sequential and keyword arguments taken
from the args and kwargs arguments, respectively.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self):
    try:
        if self.target:
            self.results = self.target(*self.args, **self.kwargs)
    finally:
        del self.target, self.args, self.kwargs</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="lupro_scheduler.Thread.ThreadMap"><code class="flex name class">
<span>class <span class="ident">ThreadMap</span></span>
<span>(</span><span>target=None, *args: Iterable[tuple], kwargs: Iterable[dict] = None, name: Iterable = None, daemon: Iterable = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Thread map method</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ThreadMap():
    &#39;&#39;&#39;Thread map method&#39;&#39;&#39;

    def __init__(self, target = None, *args : &#34;Iterable[tuple]&#34;, kwargs : &#34;Iterable[dict]&#34; = None, name : Iterable = None,  daemon : Iterable = None):
        if not (args or name or kwargs or daemon or isinstance(target, Iterable)):
            raise TypeError(&#34;ThreadMap() missing 1 required positional argument: &#39;iterable&#39;&#34;)
        d = {&#39;args&#39;: (), &#39;name&#39; : None, &#39;kwargs&#39; : None, &#39;daemon&#39; : None}
        self.task = []
        self.l = 0
        if target and isinstance(target, Iterable):
            self.l = len(target)
            d[&#39;func&#39;] = target
        if args:
            d[&#39;args&#39;] = list(zip(*args))
            self.l = len(d[&#39;args&#39;])
        if name:
            d[&#39;name&#39;] = name
            if not self.l:
                self.l = len(args)
        if kwargs:
            d[&#39;kwargs&#39;] = kwargs
            if not self.l:
                self.l = len(d[&#39;kwargs&#39;])
        if daemon:
            d[&#39;daemon&#39;] = daemon
            if not self.l:
                self.l = len(daemon)
        for i in d:
            if not d[i]:
                d[i] = [d[i]]*self.l
        if isinstance(target, Callable):
            self.task = [Thread(target = target, name = d[&#39;args&#39;][i],args = d[&#39;args&#39;][i], kwargs = d[&#39;kwargs&#39;][i], daemon = d[&#39;daemon&#39;][i]) for i in range(self.l)]
        else:
            self.task = [Thread(target = d[&#39;func&#39;][i], name = d[&#39;args&#39;][i],args = d[&#39;args&#39;][i], kwargs = d[&#39;kwargs&#39;][i], daemon = d[&#39;daemon&#39;][i]) for i in range(self.l)]
        del d
        
    def start(self):
        for i in self.task:
            i.start()
    
    def join(self):
        for i in self.task:
            i.join()

    def result(self):
        self.join()
        return [i.result() for i in self.task]

    def run(self, method = 0, join = True):
        if method == 0:
            self.start()
            if join:
                self.join()
        else:
            raise TypeError(
                f&#34;ThreadMap.run.method({method}) not in Enum RunThreadMap!&#34;)
        return self.result()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="lupro_scheduler.Thread.ThreadMap.join"><code class="name flex">
<span>def <span class="ident">join</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def join(self):
    for i in self.task:
        i.join()</code></pre>
</details>
</dd>
<dt id="lupro_scheduler.Thread.ThreadMap.result"><code class="name flex">
<span>def <span class="ident">result</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def result(self):
    self.join()
    return [i.result() for i in self.task]</code></pre>
</details>
</dd>
<dt id="lupro_scheduler.Thread.ThreadMap.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self, method=0, join=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self, method = 0, join = True):
    if method == 0:
        self.start()
        if join:
            self.join()
    else:
        raise TypeError(
            f&#34;ThreadMap.run.method({method}) not in Enum RunThreadMap!&#34;)
    return self.result()</code></pre>
</details>
</dd>
<dt id="lupro_scheduler.Thread.ThreadMap.start"><code class="name flex">
<span>def <span class="ident">start</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start(self):
    for i in self.task:
        i.start()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="lupro_scheduler.Thread.ThreadPool"><code class="flex name class">
<span>class <span class="ident">ThreadPool</span></span>
<span>(</span><span>func: Union[list, Callable], *args, kwargs=[])</span>
</code></dt>
<dd>
<div class="desc"><p>concurrent.futures.ThreadPoolExecutor method</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ThreadPool():
    &#39;&#39;&#39;concurrent.futures.ThreadPoolExecutor method&#39;&#39;&#39;

    def __init__(self, func : Union[list, Callable], *args, kwargs = []):
        init_task(self, func = func, args = args, kwargs = kwargs)

    def start(self, max_workers = None, thread_name_prefix=&#39;&#39;, initializer=None, initargs=(), timeout=None, chunksize=1):
        with ThreadPoolExecutor(max_workers, thread_name_prefix , initializer, initargs) as pool:
            if isinstance(self.func, Callable):
                self.task = pool.map(self.func, *self.args, timeout = timeout, chunksize = chunksize)
            else:
                self.task = [pool.submit(self.func[i], *self.d[&#39;args&#39;][i]) for i in range(self.l)]

    def result(self):
        if isinstance(self.task, list):
            return [i.result() for i in self.task]
        return list(self.task)

    def run(self, method = 0):
        if method == 0:
            self.start()
        else:
            raise TypeError(
                f&#34;ThreadPool.run.method({method}) not in Enum ThreadPool!&#34;)
        return self.result()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="lupro_scheduler.Thread.ThreadPool.result"><code class="name flex">
<span>def <span class="ident">result</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def result(self):
    if isinstance(self.task, list):
        return [i.result() for i in self.task]
    return list(self.task)</code></pre>
</details>
</dd>
<dt id="lupro_scheduler.Thread.ThreadPool.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self, method=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self, method = 0):
    if method == 0:
        self.start()
    else:
        raise TypeError(
            f&#34;ThreadPool.run.method({method}) not in Enum ThreadPool!&#34;)
    return self.result()</code></pre>
</details>
</dd>
<dt id="lupro_scheduler.Thread.ThreadPool.start"><code class="name flex">
<span>def <span class="ident">start</span></span>(<span>self, max_workers=None, thread_name_prefix='', initializer=None, initargs=(), timeout=None, chunksize=1)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start(self, max_workers = None, thread_name_prefix=&#39;&#39;, initializer=None, initargs=(), timeout=None, chunksize=1):
    with ThreadPoolExecutor(max_workers, thread_name_prefix , initializer, initargs) as pool:
        if isinstance(self.func, Callable):
            self.task = pool.map(self.func, *self.args, timeout = timeout, chunksize = chunksize)
        else:
            self.task = [pool.submit(self.func[i], *self.d[&#39;args&#39;][i]) for i in range(self.l)]</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="lupro_scheduler" href="index.html">lupro_scheduler</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="lupro_scheduler.Thread.Thread" href="#lupro_scheduler.Thread.Thread">Thread</a></code></h4>
<ul class="">
<li><code><a title="lupro_scheduler.Thread.Thread.result" href="#lupro_scheduler.Thread.Thread.result">result</a></code></li>
<li><code><a title="lupro_scheduler.Thread.Thread.run" href="#lupro_scheduler.Thread.Thread.run">run</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="lupro_scheduler.Thread.ThreadMap" href="#lupro_scheduler.Thread.ThreadMap">ThreadMap</a></code></h4>
<ul class="">
<li><code><a title="lupro_scheduler.Thread.ThreadMap.join" href="#lupro_scheduler.Thread.ThreadMap.join">join</a></code></li>
<li><code><a title="lupro_scheduler.Thread.ThreadMap.result" href="#lupro_scheduler.Thread.ThreadMap.result">result</a></code></li>
<li><code><a title="lupro_scheduler.Thread.ThreadMap.run" href="#lupro_scheduler.Thread.ThreadMap.run">run</a></code></li>
<li><code><a title="lupro_scheduler.Thread.ThreadMap.start" href="#lupro_scheduler.Thread.ThreadMap.start">start</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="lupro_scheduler.Thread.ThreadPool" href="#lupro_scheduler.Thread.ThreadPool">ThreadPool</a></code></h4>
<ul class="">
<li><code><a title="lupro_scheduler.Thread.ThreadPool.result" href="#lupro_scheduler.Thread.ThreadPool.result">result</a></code></li>
<li><code><a title="lupro_scheduler.Thread.ThreadPool.run" href="#lupro_scheduler.Thread.ThreadPool.run">run</a></code></li>
<li><code><a title="lupro_scheduler.Thread.ThreadPool.start" href="#lupro_scheduler.Thread.ThreadPool.start">start</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>